{"version":3,"sources":["useMultipleSelection.js"],"names":["Object","defineProperty","exports","value","useMultipleSelection","_shared","require","_react","_collection","_useTree","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","obj","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","prototype","toString","call","slice","constructor","name","test","len","arr2","_i","_arr","_n","_d","_s","_e","next","done","err","props","_props$defaultSelecte","selectionMode","layoutKeys","useRef","Map","intermediateKeys","Set","_useInternalState","useInternalState","defaultName","defaultValue","defaultSelectedKeys","handleName","onChange","onSelectionChange","selectedKeys","_useInternalState2","setSelectionKeys","isUncontrolled","useMemo","intermediates","current","keyMap","get","children","unselected","some","has","createPartialLayoutItem","useCallback","lazyChild","loc","parentKey","set","_keyMap","concat","undefined","unmount","delete","_keyMap2","size","toggleParentSelection","hasIntermediate","selecteds","parentKeyMap","add","toggleLazyChildrenSelection","item","currentKey","select","nestedKey","index","getKey","id","toggleChildrenSelection","_props$items","tree","createImmutableTree","items","node","nodeByPath","childrenKeyMap","toggleSelection","_selecteds","isIntermediate","replaceIntermediateKeys"],"mappings":"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","file":"useMultipleSelection.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useMultipleSelection = useMultipleSelection;\n\nvar _shared = require(\"@clayui/shared\");\n\nvar _react = require(\"react\");\n\nvar _collection = require(\"../collection\");\n\nvar _useTree = require(\"./useTree\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * The selection hook implementation handles the responsibility of optimizing\n * the tree selection in more complex scenarios like multiple recursive\n * selection, recursively selecting in two directions from the point where the\n * item is in the tree.\n *\n * Root\n * ├─ Item 0\n * ├─ Item 1\n * │  ├─ Item 2 <- Select this item.\n * │  │  ├─ Item 3\n * │  │  ├─ Item 4\n * │  ├─ Item 5\n *\n * Selecting the item must recursively navigate up and down from the item's\n * point in the tree to the end at each end, the selection rules are different\n * when navigating up and down.\n *\n * {\n *  'Item 1': {\n *    children: ['Item 2', 'Item 5'],\n *    parentKey: 'Root'\n *  }\n * }\n *\n * Navigation in the tree is supported by a hashmap structure with linked list\n * that avoids the operation of traversing the tree in search of all parent and\n * childs items. Navigation done this way lets you go from 1 to 1.\n *\n * Assembling the `layoutKeys` structure is also optimized to avoid traversing\n * the entire tree and blocking rendering until the operation is finished,\n * instead, the hook embodies the concept of building the structure in\n * React flow, i.e. when the item component is rendered, the record is added\n * to `layoutKeys` and and keeping the structure up to date is free because the\n * method is called on component mount and unmount. The trade-off is that we\n * don't get the complete mirror of the tree in the hashmap but only what is\n * rendered, this decreases the amount of data when there is a big tree but we\n * have problems recursively selecting to down.\n *\n * Root [0]\n * ├─ Item 0 [0, 0]\n * ├─ Item 1 [0, 1]\n * │  ├─ Item 2 [0, 1, 0]\n * │  │  ├─ Item 3 [0, 1, 0, 0]\n * │  │  ├─ Item 4 [0, 1, 0, 1]\n * │  ├─ Item 5 [0, 1, 1]\n *\n * The implementation solves this with a fallback approach of identifying if\n * the item has unrendered children and using the tree to navigate but using\n * the item path to avoid traversing the entire tree.\n */\nfunction useMultipleSelection(props) {\n  var _props$defaultSelecte;\n\n  var selectionMode = props.selectionMode;\n  var layoutKeys = (0, _react.useRef)(new Map());\n  var intermediateKeys = (0, _react.useRef)(new Set());\n\n  var _useInternalState = (0, _shared.useInternalState)({\n    defaultName: 'defaultSelectedKeys',\n    defaultValue: (_props$defaultSelecte = props.defaultSelectedKeys) !== null && _props$defaultSelecte !== void 0 ? _props$defaultSelecte : new Set(),\n    handleName: 'onSelectionChange',\n    name: 'selectedKeys',\n    onChange: props.onSelectionChange,\n    value: props.selectedKeys\n  }),\n      _useInternalState2 = _slicedToArray(_useInternalState, 3),\n      selectedKeys = _useInternalState2[0],\n      setSelectionKeys = _useInternalState2[1],\n      isUncontrolled = _useInternalState2[2];\n  /**\n   * We are using `useMemo` to do intermediate state revalidation in the\n   * render cycle instead of in the `useEffect` which happens after rendering.\n   */\n\n\n  (0, _react.useMemo)(function () {\n    if (props.selectionMode === 'multiple-recursive' && !isUncontrolled) {\n      var intermediates = Array.from(intermediateKeys.current);\n      intermediateKeys.current = new Set(intermediates.filter(function (key) {\n        var keyMap = layoutKeys.current.get(key);\n\n        var children = _toConsumableArray(keyMap.children);\n\n        var unselected = children.some(function (key) {\n          return !selectedKeys.has(key);\n        });\n\n        if (unselected) {\n          if (children.some(function (key) {\n            return selectedKeys.has(key) || intermediateKeys.current.has(key);\n          })) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }));\n    }\n  }, [selectedKeys]);\n  /**\n   * The method creates the mirror of the tree in a hashmap structure with a\n   * linked list using `parentKey` and `children`. Adding data to the structure\n   * is reactive to item component rendering and disassembly. Only the rendered\n   * items are in the structure, if a component is moved, removed, or added the\n   * structure is updated automatically.\n   *\n   * useEffect(() => createPartialLayoutItem(...), []);\n   *\n   * The design of this method is to be coupled to `useEffect` which has the\n   * mount and unmount behavior, also handles lifecycle and call order,\n   * `useEffect` in nested components are called bottom-up instead of top-down\n   * as in rendering.\n   */\n\n  var createPartialLayoutItem = (0, _react.useCallback)(function (key, lazyChild, loc, parentKey) {\n    var keyMap = layoutKeys.current.get(key);\n\n    if (!keyMap) {\n      layoutKeys.current.set(key, {\n        children: new Set(),\n        lazyChild: lazyChild,\n        loc: loc,\n        parentKey: parentKey\n      });\n    } else if (keyMap.parentKey !== parentKey) {\n      layoutKeys.current.set(key, _objectSpread(_objectSpread({}, keyMap), {}, {\n        parentKey: parentKey\n      }));\n    }\n\n    if (parentKey) {\n      var _keyMap = layoutKeys.current.get(parentKey);\n\n      if (_keyMap) {\n        layoutKeys.current.set(parentKey, _objectSpread(_objectSpread({}, _keyMap), {}, {\n          children: new Set([].concat(_toConsumableArray(_keyMap.children), [key])),\n          lazyChild: false\n        }));\n      } else {\n        // Pre-initializes the parent layout, as this is linked to\n        // React rendering, the mount is used inside `useEffect`\n        // this causes callbacks from the last rendering to be\n        // called first than parents, starting from the bottom up.\n        //\n        // We just add an initial value then update the parentKey\n        // when the corresponding one is called.\n        layoutKeys.current.set(parentKey, {\n          children: new Set([key]),\n          lazyChild: false,\n          loc: loc.slice(0, -1),\n          parentKey: undefined\n        });\n      }\n    }\n\n    return function unmount() {\n      layoutKeys.current.delete(key);\n\n      if (parentKey && layoutKeys.current.has(parentKey)) {\n        var _keyMap2 = layoutKeys.current.get(parentKey);\n\n        var children = new Set(_keyMap2.children);\n        children.delete(key);\n        layoutKeys.current.set(parentKey, _objectSpread(_objectSpread({}, _keyMap2), {}, {\n          children: children,\n          lazyChild: children.size === 0\n        }));\n      }\n    };\n  }, [layoutKeys]);\n  var toggleParentSelection = (0, _react.useCallback)(function (hasIntermediate, keyMap, selecteds) {\n    if (!keyMap.parentKey) {\n      return;\n    }\n\n    var parentKeyMap = layoutKeys.current.get(keyMap.parentKey); // Root\n    // ├─ Item 0\n    // ├─ Item 1 <- Current recursion flow\n    // │  ├─ (Intermediate) Item 2\n    // │  │  ├─ (Checked) Item 3 <- Start\n    // │  │  ├─ Item 4\n    //\n    // As the method works recursively from the item's point in the tree\n    // to up, if the item's parent was already marked as intermediate, from\n    // here we start to mark all the parents as intermediate to avoid\n    // unnecessary operations.\n\n    if (hasIntermediate) {\n      intermediateKeys.current.add(keyMap.parentKey);\n      selecteds.delete(keyMap.parentKey);\n    } else {\n      var children = _toConsumableArray(parentKeyMap.children); // Instead of using `every` method to check if all items are\n      // selected, we look for any not selected, which means we don't have\n      // all the items selected and we don't always need to go through the\n      // entire array.\n\n\n      var unselected = children.some(function (key) {\n        return !selecteds.has(key);\n      });\n\n      if (unselected) {\n        // An item can only be intermediate when there is at least\n        // one selected or intermediate item in its tree. We don't need\n        // to sweep the tree because we have the recursive effect.\n        if (children.some(function (key) {\n          return selecteds.has(key) || intermediateKeys.current.has(key);\n        })) {\n          intermediateKeys.current.add(keyMap.parentKey);\n        } else {\n          intermediateKeys.current.delete(keyMap.parentKey);\n        }\n\n        selecteds.delete(keyMap.parentKey);\n      } else {\n        intermediateKeys.current.delete(keyMap.parentKey);\n        selecteds.add(keyMap.parentKey);\n      }\n    }\n\n    toggleParentSelection(intermediateKeys.current.has(keyMap.parentKey), parentKeyMap, selecteds);\n  }, [layoutKeys, intermediateKeys]);\n  var toggleLazyChildrenSelection = (0, _react.useCallback)(function (item, currentKey, selecteds, select) {\n    var children = item[props.nestedKey];\n\n    if (!children) {\n      return;\n    }\n\n    children.forEach(function (item, index) {\n      // TODO: The `key` property of the component that the developer\n      // can set is not being considered.\n      var key = (0, _collection.getKey)(index, item.id, currentKey);\n\n      if (select) {\n        selecteds.add(key);\n      } else {\n        selecteds.delete(key);\n      }\n\n      toggleLazyChildrenSelection(item, key, selecteds, select);\n    });\n  }, [props.nestedKey]);\n  /**\n   * The recursive selection of children of an item is done using the\n   * `layoutKeys` structure which is the representation of the items rendered\n   * in the DOM, when the child is not rendered in the DOM the method uses the\n   * fallback of the tree to continue the recursion from where it left off.\n   */\n\n  var toggleChildrenSelection = (0, _react.useCallback)(function (keyMap, currentKey, selecteds, select) {\n    if (keyMap.lazyChild) {\n      var _props$items;\n\n      var tree = (0, _useTree.createImmutableTree)((_props$items = props.items) !== null && _props$items !== void 0 ? _props$items : [], props.nestedKey);\n      var node = tree.nodeByPath(keyMap.loc);\n      return toggleLazyChildrenSelection(node.item, currentKey, selecteds, select);\n    }\n\n    if (!keyMap.children.size) {\n      return;\n    }\n\n    keyMap.children.forEach(function (key) {\n      if (select) {\n        selecteds.add(key);\n      } else {\n        selecteds.delete(key);\n      }\n\n      var childrenKeyMap = layoutKeys.current.get(key);\n      toggleChildrenSelection(childrenKeyMap, key, selecteds, select);\n    });\n  }, [toggleLazyChildrenSelection, layoutKeys, props.items, props.nestedKey]);\n  var toggleSelection = (0, _react.useCallback)(function (key) {\n    switch (selectionMode) {\n      case 'multiple':\n        {\n          var selecteds = new Set(selectedKeys);\n\n          if (selecteds.has(key)) {\n            selecteds.delete(key);\n          } else {\n            selecteds.add(key);\n          }\n\n          setSelectionKeys(selecteds);\n          break;\n        }\n\n      case 'multiple-recursive':\n        {\n          var _selecteds = new Set(selectedKeys);\n\n          var keyMap = layoutKeys.current.get(key);\n\n          if (_selecteds.has(key)) {\n            _selecteds.delete(key);\n          } else if (!intermediateKeys.current.has(key)) {\n            _selecteds.add(key);\n          } // Resets the intermediate state because its selected state\n          // will change.\n\n\n          intermediateKeys.current.delete(key);\n          toggleChildrenSelection(keyMap, key, _selecteds, _selecteds.has(key));\n          toggleParentSelection(false, keyMap, _selecteds);\n          setSelectionKeys(_selecteds);\n          break;\n        }\n\n      default:\n        {\n          if (selectedKeys.has(key)) {\n            setSelectionKeys(new Set());\n          } else {\n            setSelectionKeys(new Set([key]));\n          }\n\n          break;\n        }\n    }\n  }, [layoutKeys, intermediateKeys, selectedKeys, selectionMode, toggleChildrenSelection, toggleParentSelection]);\n  var isIntermediate = (0, _react.useCallback)(function (key) {\n    return intermediateKeys.current.has(key);\n  }, [intermediateKeys]);\n  var replaceIntermediateKeys = (0, _react.useCallback)(function (keys) {\n    intermediateKeys.current = new Set(keys);\n  }, [intermediateKeys]);\n  return {\n    createPartialLayoutItem: createPartialLayoutItem,\n    isIntermediate: isIntermediate,\n    replaceIntermediateKeys: replaceIntermediateKeys,\n    selectedKeys: selectedKeys,\n    toggleSelection: toggleSelection\n  };\n}"]}