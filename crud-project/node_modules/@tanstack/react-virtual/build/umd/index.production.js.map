{"version":3,"file":"index.production.js","sources":["../../../virtual-core/build/esm/index.js","../../src/index.tsx"],"sourcesContent":["/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nvar props = [\"bottom\", \"height\", \"left\", \"right\", \"top\", \"width\"];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return () => {\n    let depTime;\n    if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n\n    if (!depsChanged) {\n      return result;\n    }\n\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n\n    if (opts.key && opts.debug != null && opts.debug()) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n\n      const pad = (str, num) => {\n        str = String(str);\n\n        while (str.length < num) {\n          str = ' ' + str;\n        }\n\n        return str;\n      };\n\n      console.info(\"%c\\u23F1 \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n    }\n\n    return result;\n  };\n}\n\n//\nconst defaultKeyExtractor = index => index;\nconst defaultRangeExtractor = range => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\n\nconst memoRectCallback = (instance, cb) => {\n  let prev = {\n    height: -1,\n    width: -1\n  };\n  return rect => {\n    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {\n      cb(rect);\n    }\n\n    prev = rect;\n  };\n};\n\nconst observeElementRect = (instance, cb) => {\n  const onResize = memoRectCallback(instance, cb);\n  const observer = observeRect(instance.scrollElement, rect => {\n    onResize(rect);\n  });\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  onResize(instance.scrollElement.getBoundingClientRect());\n  observer.observe();\n  return () => {\n    observer.unobserve();\n  };\n};\nconst observeWindowRect = (instance, cb) => {\n  const memoizedCallback = memoRectCallback(instance, cb);\n\n  const onResize = () => memoizedCallback({\n    width: instance.scrollElement.innerWidth,\n    height: instance.scrollElement.innerHeight\n  });\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  onResize();\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true\n  });\n  return () => {\n    instance.scrollElement.removeEventListener('resize', onResize);\n  };\n};\nconst scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY']\n};\n\nconst createOffsetObserver = mode => {\n  return (instance, cb) => {\n    if (!instance.scrollElement) {\n      return;\n    }\n\n    const propX = scrollProps[mode][0];\n    const propY = scrollProps[mode][1];\n    let prevX = instance.scrollElement[propX];\n    let prevY = instance.scrollElement[propY];\n\n    const scroll = () => {\n      cb(instance.scrollElement[instance.options.horizontal ? propX : propY]);\n    };\n\n    scroll();\n\n    const onScroll = e => {\n      const target = e.currentTarget;\n      const scrollX = target[propX];\n      const scrollY = target[propY];\n\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll();\n      }\n\n      prevX = scrollX;\n      prevY = scrollY;\n    };\n\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return () => {\n      instance.scrollElement.removeEventListener('scroll', onScroll);\n    };\n  };\n};\n\nconst observeElementOffset = createOffsetObserver('element');\nconst observeWindowOffset = createOffsetObserver('window');\nconst measureElement = (element, instance) => {\n  return element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height'];\n};\nconst windowScroll = (offset, canSmooth, instance) => {\n  var _instance$scrollEleme;\n  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: offset,\n    behavior: canSmooth ? 'smooth' : undefined\n  });\n};\nconst elementScroll = (offset, canSmooth, instance) => {\n  var _instance$scrollEleme2;\n  (_instance$scrollEleme2 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme2.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: offset,\n    behavior: canSmooth ? 'smooth' : undefined\n  });\n};\nclass Virtualizer {\n  constructor(_opts) {\n    var _this = this;\n\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.measurementsCache = [];\n    this.itemMeasurementsCache = {};\n    this.pendingMeasuredCacheIndexes = [];\n    this.measureElementCache = {};\n\n    this.setOptions = opts => {\n      Object.entries(opts).forEach(_ref => {\n        let [key, value] = _ref;\n        if (typeof value === 'undefined') delete opts[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        enableSmoothScroll: true,\n        onChange: () => {},\n        measureElement,\n        initialRect: {\n          width: 0,\n          height: 0\n        },\n        ...opts\n      };\n    };\n\n    this.notify = () => {\n      var _this$options$onChang, _this$options;\n\n      (_this$options$onChang = (_this$options = this.options).onChange) == null ? void 0 : _this$options$onChang.call(_this$options, this);\n    };\n\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach(d => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this.unsubs.push(this.options.observeElementRect(this, rect => {\n          this.scrollRect = rect;\n          this.notify();\n        }));\n        this.unsubs.push(this.options.observeElementOffset(this, offset => {\n          this.scrollOffset = offset;\n          this.notify();\n        }));\n      }\n    };\n\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? 'width' : 'height'];\n    };\n\n    this.getMeasurements = memo(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (count, paddingStart, getItemKey, measurementsCache) => {\n      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n      this.pendingMeasuredCacheIndexes = [];\n      const measurements = this.measurementsCache.slice(0, min);\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i);\n        const measuredSize = measurementsCache[key];\n        const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n        const size = typeof measuredSize === 'number' ? measuredSize : this.options.estimateSize(i);\n        const end = start + size;\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key\n        };\n      }\n\n      this.measurementsCache = measurements;\n      return measurements;\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getMeasurements',\n      debug: () => this.options.debug\n    });\n    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {\n      return calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset\n      });\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'calculateRange',\n      debug: () => this.options.debug\n    });\n    this.getIndexes = memo(() => [this.options.rangeExtractor, this.calculateRange(), this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {\n      return rangeExtractor({ ...range,\n        overscan,\n        count: count\n      });\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getIndexes'\n    });\n    this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (indexes, measurements, measureElement) => {\n      const makeMeasureElement = index => measurableItem => {\n        var _this$itemMeasurement;\n\n        const item = this.measurementsCache[index];\n\n        if (!measurableItem) {\n          return;\n        }\n\n        const measuredItemSize = measureElement(measurableItem, this);\n        const itemSize = (_this$itemMeasurement = this.itemMeasurementsCache[item.key]) != null ? _this$itemMeasurement : item.size;\n\n        if (measuredItemSize !== itemSize) {\n          if (item.start < this.scrollOffset) {\n            if (process.env.NODE_ENV === 'development' && this.options.debug) {\n              console.info('correction', measuredItemSize - itemSize);\n            }\n\n            if (!this.destinationOffset) {\n              this._scrollToOffset(this.scrollOffset + (measuredItemSize - itemSize), false);\n            }\n          }\n\n          this.pendingMeasuredCacheIndexes.push(index);\n          this.itemMeasurementsCache = { ...this.itemMeasurementsCache,\n            [item.key]: measuredItemSize\n          };\n          this.notify();\n        }\n      };\n\n      const virtualItems = [];\n      const currentMeasureElements = {};\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        var _this$measureElementC;\n\n        const i = indexes[k];\n        const measurement = measurements[i];\n        const item = { ...measurement,\n          measureElement: currentMeasureElements[i] = (_this$measureElementC = this.measureElementCache[i]) != null ? _this$measureElementC : makeMeasureElement(i)\n        };\n        virtualItems.push(item);\n      }\n\n      this.measureElementCache = currentMeasureElements;\n      return virtualItems;\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getIndexes'\n    });\n\n    this.scrollToOffset = function (toOffset, _temp) {\n      let {\n        align\n      } = _temp === void 0 ? {\n        align: 'start'\n      } : _temp;\n\n      const attempt = () => {\n        const offset = _this.scrollOffset;\n\n        const size = _this.getSize();\n\n        if (align === 'auto') {\n          if (toOffset <= offset) {\n            align = 'start';\n          } else if (toOffset >= offset + size) {\n            align = 'end';\n          } else {\n            align = 'start';\n          }\n        }\n\n        if (align === 'start') {\n          _this._scrollToOffset(toOffset, true);\n        } else if (align === 'end') {\n          _this._scrollToOffset(toOffset - size, true);\n        } else if (align === 'center') {\n          _this._scrollToOffset(toOffset - size / 2, true);\n        }\n      };\n\n      attempt();\n      requestAnimationFrame(() => {\n        attempt();\n      });\n    };\n\n    this.scrollToIndex = function (index, _temp2) {\n      let {\n        align,\n        ...rest\n      } = _temp2 === void 0 ? {\n        align: 'auto'\n      } : _temp2;\n\n      const measurements = _this.getMeasurements();\n\n      const offset = _this.scrollOffset;\n\n      const size = _this.getSize();\n\n      const {\n        count\n      } = _this.options;\n      const measurement = measurements[Math.max(0, Math.min(index, count - 1))];\n\n      if (!measurement) {\n        return;\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {\n          align = 'end';\n        } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {\n          align = 'start';\n        } else {\n          return;\n        }\n      }\n\n      const toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n\n      _this.scrollToOffset(toOffset, {\n        align,\n        ...rest\n      });\n    };\n\n    this.getTotalSize = () => {\n      var _this$getMeasurements;\n\n      return (((_this$getMeasurements = this.getMeasurements()[this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || this.options.paddingStart) + this.options.paddingEnd;\n    };\n\n    this._scrollToOffset = (offset, canSmooth) => {\n      clearTimeout(this.scrollCheckFrame);\n      this.destinationOffset = offset;\n      this.options.scrollToFn(offset, this.options.enableSmoothScroll && canSmooth, this);\n      let scrollCheckFrame;\n\n      const check = () => {\n        let lastOffset = this.scrollOffset;\n        this.scrollCheckFrame = scrollCheckFrame = setTimeout(() => {\n          if (this.scrollCheckFrame !== scrollCheckFrame) {\n            return;\n          }\n\n          if (this.scrollOffset === lastOffset) {\n            this.destinationOffset = undefined;\n            return;\n          }\n\n          lastOffset = this.scrollOffset;\n          check();\n        }, 100);\n      };\n\n      check();\n    };\n\n    this.measure = () => {\n      this.itemMeasurementsCache = {};\n      this.notify();\n    };\n\n    this.setOptions(_opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n  }\n\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref2) {\n  let {\n    measurements,\n    outerSize,\n    scrollOffset\n  } = _ref2;\n  const count = measurements.length - 1;\n\n  const getOffset = index => measurements[index].start;\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n\n  return {\n    startIndex,\n    endIndex\n  };\n}\n\nexport { Virtualizer, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\nimport {\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  PartialKeys,\n  Virtualizer,\n  VirtualizerOptions,\n  windowScroll,\n} from '@tanstack/virtual-core'\nexport * from '@tanstack/virtual-core'\n\n//\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<TScrollElement, TItemElement = unknown>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance) => {\n      rerender()\n      options.onChange?.(instance)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<TScrollElement, TItemElement = unknown>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement = unknown>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof window !== 'undefined' ? window : null!),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    ...options,\n  })\n}\n"],"names":["rafId","props","observedNodes","Map","run","changedStates","forEach","state","node","a","b","newRect","getBoundingClientRect","rect","some","prop","push","callbacks","cb","window","requestAnimationFrame","memo","getDeps","fn","opts","result","deps","depTime","key","debug","Date","now","newDeps","length","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","i","memoRectCallback","instance","prev","height","width","options","horizontal","observeElementRect","onResize","observer","observe","wasEmpty","size","has","get","set","undefined","hasRectChanged","unobserve","indexOf","splice","cancelAnimationFrame","observeRect","scrollElement","observeWindowRect","memoizedCallback","innerWidth","innerHeight","addEventListener","capture","passive","removeEventListener","scrollProps","element","createOffsetObserver","mode","propX","propY","prevX","prevY","scroll","onScroll","e","target","currentTarget","scrollX","scrollY","observeElementOffset","observeWindowOffset","measureElement","windowScroll","offset","canSmooth","_instance$scrollEleme","scrollTo","behavior","elementScroll","_instance$scrollEleme2","Virtualizer","constructor","_opts","_this","this","unsubs","measurementsCache","itemMeasurementsCache","pendingMeasuredCacheIndexes","measureElementCache","setOptions","Object","entries","_ref","value","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","enableSmoothScroll","initialRect","notify","_this$options$onChang","_this$options","call","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","scrollRect","scrollOffset","getSize","getMeasurements","measurements","slice","measuredSize","estimateSize","calculateRange","outerSize","_ref2","low","high","getCurrentValue","middle","currentValue","findNearestBinarySearch","getIndexes","getVirtualItems","indexes","makeMeasureElement","measurableItem","_this$itemMeasurement","item","measuredItemSize","itemSize","destinationOffset","_scrollToOffset","virtualItems","currentMeasureElements","k","len","_this$measureElementC","scrollToOffset","toOffset","_temp","align","attempt","scrollToIndex","_temp2","rest","measurement","getTotalSize","_this$getMeasurements","scrollCheckFrame","clearTimeout","scrollToFn","check","lastOffset","setTimeout","measure","useIsomorphicLayoutEffect","React","useLayoutEffect","useEffect","useVirtualizerBase","rerender","useReducer","resolvedOptions","useState"],"mappings":"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"}